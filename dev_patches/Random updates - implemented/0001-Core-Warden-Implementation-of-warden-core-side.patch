From 9b10f612a672f2ad3207191e39c8bac7c73c1112 Mon Sep 17 00:00:00 2001
From: MobileDev <Stage6@EMPulsegaming.com>
Date: Thu, 30 Jun 2011 02:08:47 -0500
Subject: [PATCH] Core/Warden: Implementation of warden (core-side)

---
 src/server/authserver/Server/AuthSocket.cpp        |    8 +-
 src/server/authserver/Server/AuthSocket.h          |    1 +
 src/server/game/CMakeLists.txt                     |    3 +
 .../Server/Protocol/Handlers/CharacterHandler.cpp  |    2 +
 .../game/Server/Protocol/Handlers/MiscHandler.cpp  |   10 -
 src/server/game/Server/Protocol/Opcodes.cpp        |    2 +-
 src/server/game/Server/WorldSession.cpp            |   10 +-
 src/server/game/Server/WorldSession.h              |   20 +
 src/server/game/Server/WorldSocket.cpp             |    2 +-
 src/server/game/Server/WorldSocket.h               |    6 +
 src/server/game/Warden/WardenMgr.cpp               | 1361 ++++++++++++++++++++
 src/server/game/Warden/WardenMgr.h                 |  234 ++++
 src/server/game/Warden/WardenProtocol.h            |   73 ++
 src/server/game/World/World.cpp                    |   43 +
 src/server/game/World/World.h                      |    3 +
 .../Database/Implementation/LoginDatabase.cpp      |    2 +-
 src/server/shared/Packets/ByteBuffer.h             |   11 +
 src/server/shared/Utilities/Util.cpp               |   97 ++-
 src/server/shared/Utilities/Util.h                 |   11 +
 doc/HowToBuildWarden_Wine.txt                      |   56 ++++++++++++++++++++
 src/server/worldserver/worldserver.conf.dist       |   34 +
 21 files changed, 1970 insertions(+), 18 deletions(-)
 create mode 100644 src/server/game/Warden/WardenMgr.cpp
 create mode 100644 src/server/game/Warden/WardenMgr.h
 create mode 100644 src/server/game/Warden/WardenProtocol.h
 create mode 100644 doc/HowToBuildWarden_Wine.txt
 
diff --git a/src/server/authserver/Server/AuthSocket.cpp b/src/server/authserver/Server/AuthSocket.cpp
index 8ec1fcd..20c691b 100644
--- a/src/server/authserver/Server/AuthSocket.cpp
+++ b/src/server/authserver/Server/AuthSocket.cpp
@@ -68,7 +68,7 @@ typedef struct AUTH_LOGON_CHALLENGE_C
     uint8   version3;
     uint16  build;
     uint8   platform[4];
-    uint8   os[4];
+    uint8   os;
     uint8   country[4];
     uint32  timezone_bias;
     uint32  ip;
@@ -331,7 +331,7 @@ bool AuthSocket::_HandleLogonChallenge()
     EndianConvert(*((uint32*)(&ch->gamename[0])));
     EndianConvert(ch->build);
     EndianConvert(*((uint32*)(&ch->platform[0])));
-    EndianConvert(*((uint32*)(&ch->os[0])));
+    EndianConvert(ch->os);
     EndianConvert(*((uint32*)(&ch->country[0])));
     EndianConvert(ch->timezone_bias);
     EndianConvert(ch->ip);
@@ -599,7 +599,8 @@ bool AuthSocket::_HandleLogonProof()
         stmt->setString(0, K_hex);
         stmt->setString(1, socket().get_remote_address().c_str());
         stmt->setUInt32(2, GetLocaleByName(_localizationName));
-        stmt->setString(3, _login);
+        stmt->setUInt32(3, _os);
+        stmt->setString(4, _login);
         LoginDatabase.Execute(stmt);
 
         OPENSSL_free((void*)K_hex);
@@ -736,6 +737,7 @@ bool AuthSocket::_HandleReconnectChallenge()
 
     // Reinitialize build, expansion and the account securitylevel
     _build = ch->build;
+    _os = ch->os;  
     _expversion = (AuthHelper::IsPostBCAcceptedClientBuild(_build) ? POST_BC_EXP_FLAG : NO_VALID_EXP_FLAG) | (AuthHelper::IsPreBCAcceptedClientBuild(_build) ? PRE_BC_EXP_FLAG : NO_VALID_EXP_FLAG);
 
     Field* fields = result->Fetch();
diff --git a/src/server/authserver/Server/AuthSocket.h b/src/server/authserver/Server/AuthSocket.h
index 018af07..8393976 100644
--- a/src/server/authserver/Server/AuthSocket.h
+++ b/src/server/authserver/Server/AuthSocket.h
@@ -82,6 +82,7 @@ private:
     // between enUS and enGB, which is important for the patch system
     std::string _localizationName;
     uint16 _build;
+    uint32 _os;    
     uint8 _expversion;
     AccountTypes _accountSecurityLevel;
 };
diff --git a/src/server/game/CMakeLists.txt b/src/server/game/CMakeLists.txt
index 65ba160..d4739a6 100644
--- a/src/server/game/CMakeLists.txt
+++ b/src/server/game/CMakeLists.txt
@@ -47,6 +47,7 @@ file(GLOB_RECURSE sources_Spells Spells/*.cpp Spells/*.h)
 file(GLOB_RECURSE sources_Texts Texts/*.cpp Texts/*.h)
 file(GLOB_RECURSE sources_Tools Tools/*.cpp Tools/*.h)
 file(GLOB_RECURSE sources_Tickets Tickets/*.cpp Tickets/*.h)
+file(GLOB_RECURSE sources_Warden Warden/*.cpp Warden/*.h)
 file(GLOB_RECURSE sources_Weather Weather/*.cpp Weather/*.h)
 file(GLOB_RECURSE sources_World World/*.cpp World/*.h)
 
@@ -96,6 +97,7 @@ set(game_STAT_SRCS
   ${sources_Texts}
   ${sources_Tools}
   ${sources_Tickets}
+  ${sources_Warden}  
   ${sources_Weather}
   ${sources_World}
 )
@@ -187,6 +189,7 @@ include_directories(
   ${CMAKE_CURRENT_SOURCE_DIR}/Texts
   ${CMAKE_CURRENT_SOURCE_DIR}/Tools
   ${CMAKE_CURRENT_SOURCE_DIR}/Tickets
+  ${CMAKE_CURRENT_SOURCE_DIR}/Warden  
   ${CMAKE_CURRENT_SOURCE_DIR}/Weather
   ${CMAKE_CURRENT_SOURCE_DIR}/World
   ${CMAKE_SOURCE_DIR}/src/server/scripts/PrecompiledHeaders
diff --git a/src/server/game/Server/Protocol/Handlers/CharacterHandler.cpp b/src/server/game/Server/Protocol/Handlers/CharacterHandler.cpp
index 0424bb3..7090846 100644
--- a/src/server/game/Server/Protocol/Handlers/CharacterHandler.cpp
+++ b/src/server/game/Server/Protocol/Handlers/CharacterHandler.cpp
@@ -222,6 +222,8 @@ void WorldSession::HandleCharEnum(QueryResult result)
     data.put<uint8>(0, num);
 
     SendPacket(&data);
+    // It's time to begin warden activity
+    HandleWardenRegister();
 }
 
 void WorldSession::HandleCharEnumOpcode(WorldPacket & /*recv_data*/)
diff --git a/src/server/game/Server/Protocol/Handlers/MiscHandler.cpp b/src/server/game/Server/Protocol/Handlers/MiscHandler.cpp
index 81f771f..2744c7e 100644
--- a/src/server/game/Server/Protocol/Handlers/MiscHandler.cpp
+++ b/src/server/game/Server/Protocol/Handlers/MiscHandler.cpp
@@ -1191,16 +1191,6 @@ void WorldSession::HandleSetActionBarToggles(WorldPacket& recv_data)
     GetPlayer()->SetByteValue(PLAYER_FIELD_BYTES, 2, ActionBar);
 }
 
-void WorldSession::HandleWardenDataOpcode(WorldPacket& recv_data)
-{
-    recv_data.read_skip<uint8>();
-    /*
-        uint8 tmp;
-        recv_data >> tmp;
-        sLog->outDebug("Received opcode CMSG_WARDEN_DATA, not resolve.uint8 = %u", tmp);
-    */
-}
-
 void WorldSession::HandlePlayedTime(WorldPacket& recv_data)
 {
     uint8 unk1;
diff --git a/src/server/game/Server/Protocol/Opcodes.cpp b/src/server/game/Server/Protocol/Opcodes.cpp
index 235f349..73cbb51 100644
--- a/src/server/game/Server/Protocol/Opcodes.cpp
+++ b/src/server/game/Server/Protocol/Opcodes.cpp
@@ -769,7 +769,7 @@ OpcodeHandler opcodeTable[NUM_MSG_TYPES] =
     /*0x2E4*/ { "SMSG_AREA_SPIRIT_HEALER_TIME",                 STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_ServerSide               },
     /*0x2E5*/ { "CMSG_GM_UNTEACH",                              STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_NULL                     },
     /*0x2E6*/ { "SMSG_WARDEN_DATA",                             STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_ServerSide               },
-    /*0x2E7*/ { "CMSG_WARDEN_DATA",                             STATUS_LOGGEDIN, PROCESS_THREADUNSAFE, &WorldSession::HandleWardenDataOpcode          },
+    /*0x2E7*/ { "CMSG_WARDEN_DATA",                             STATUS_AUTHED,   PROCESS_THREADUNSAFE, &WorldSession::HandleWardenDataOpcode          },
     /*0x2E8*/ { "SMSG_GROUP_JOINED_BATTLEGROUND",               STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_ServerSide               },
     /*0x2E9*/ { "MSG_BATTLEGROUND_PLAYER_POSITIONS",            STATUS_LOGGEDIN, PROCESS_THREADUNSAFE, &WorldSession::HandleBattlegroundPlayerPositionsOpcode},
     /*0x2EA*/ { "CMSG_PET_STOP_ATTACK",                         STATUS_LOGGEDIN, PROCESS_THREADUNSAFE, &WorldSession::HandlePetStopAttack             },
diff --git a/src/server/game/Server/WorldSession.cpp b/src/server/game/Server/WorldSession.cpp
index 8fd4430..84b0039 100644
--- a/src/server/game/Server/WorldSession.cpp
+++ b/src/server/game/Server/WorldSession.cpp
@@ -30,6 +30,7 @@
 #include "Player.h"
 #include "Vehicle.h"
 #include "ObjectMgr.h"
+#include "WardenMgr.h"
 #include "GuildMgr.h"
 #include "Group.h"
 #include "Guild.h"
@@ -93,7 +94,7 @@ m_inQueue(false), m_playerLoading(false), m_playerLogout(false),
 m_playerRecentlyLogout(false), m_playerSave(false),
 m_sessionDbcLocale(sWorld->GetAvailableDbcLocale(locale)),
 m_sessionDbLocaleIndex(locale),
-m_latency(0), m_TutorialsChanged(false), recruiterId(recruiter)
+m_latency(0), m_TutorialsChanged(false), recruiterId(recruiter), m_wardenStatus(WARD_STATE_UNREGISTERED), m_WardenClientChecks(NULL)
 {
     if (sock)
     {
@@ -126,6 +127,9 @@ WorldSession::~WorldSession()
     while (_recvQueue.next(packet))
         delete packet;
 
+    ///- inform Warden Manager
+    sWardenMgr->Unregister(this);
+
     LoginDatabase.PExecute("UPDATE account SET online = 0 WHERE id = %u;", GetAccountId());
 }
 
@@ -343,6 +347,10 @@ bool WorldSession::Update(uint32 diff, PacketFilter& updater)
         if (!m_Socket)
             return false;                                       //Will remove this session from the world session map
     }
+    //Process Warden related update for this session
+    if (sWardenMgr->IsEnabled())
+        sWardenMgr->Update(this);                                //Called 2 times from Map::Update and World::UpdateSessions
+
     return true;
 }
 
diff --git a/src/server/game/Server/WorldSession.h b/src/server/game/Server/WorldSession.h
index f45ee79..08d4753 100644
--- a/src/server/game/Server/WorldSession.h
+++ b/src/server/game/Server/WorldSession.h
@@ -29,6 +29,7 @@
 #include "DatabaseEnv.h"
 #include "World.h"
 #include "WorldPacket.h"
+#include "Timer.h"
 
 struct ItemTemplate;
 struct AuctionEntry;
@@ -213,6 +214,7 @@ class CharacterCreateInfo
 /// Player session in the World
 class WorldSession
 {
+    friend class WardenMgr;    
     public:
         WorldSession(uint32 id, WorldSocket *sock, AccountTypes sec, uint8 expansion, time_t mute_time, LocaleConstant locale, uint32 recruiter);
         ~WorldSession();
@@ -391,6 +393,11 @@ class WorldSession
         // Recruit-A-Friend Handling
         uint32 GetRecruiterId() { return recruiterId; }
 
+        uint8 *GetWardenServerKey() { return &m_rc4ServerKey[0]; }
+        uint8 *GetWardenSeed() { return &m_wardenSeed[0]; }
+        uint8 *GetWardenTempClientKey() { return &m_WardenTmpClientKey[0]; }
+        void UpdateWardenTimer(uint32 diff) { m_WardenTimer.Update(diff); }
+		
     public:                                                 // opcodes handlers
 
         void Handle_NULL(WorldPacket& recvPacket);          // not used
@@ -769,7 +776,11 @@ class WorldSession
         void HandleBattlemasterJoinArena(WorldPacket &recv_data);
         void HandleReportPvPAFK(WorldPacket &recv_data);
 
+        //Warden
         void HandleWardenDataOpcode(WorldPacket& recv_data);
+        void HandleWardenRegister();                        // for internal call
+        void HandleWardenUnregister();                      // for internal call
+        
         void HandleWorldTeleportOpcode(WorldPacket& recv_data);
         void HandleMinimapPingOpcode(WorldPacket& recv_data);
         void HandleRandomRollOpcode(WorldPacket& recv_data);
@@ -951,6 +962,15 @@ class WorldSession
         AddonsList m_addonsList;
         uint32 recruiterId;
         ACE_Based::LockedQueue<WorldPacket*, ACE_Thread_Mutex> _recvQueue;
+
+        uint8 m_wardenStatus;
+        uint8 m_rc4ServerKey[0x102];
+        uint8 m_rc4ClientKey[0x102];
+        uint8 m_wardenSeed[16];
+        IntervalTimer m_WardenTimer;
+        std::string m_WardenModule;
+        void *m_WardenClientChecks;
+        uint8 m_WardenTmpClientKey[0x102];
 };
 #endif
 /// @}
diff --git a/src/server/game/Server/WorldSocket.cpp b/src/server/game/Server/WorldSocket.cpp
index b2c8164..90d2673 100644
--- a/src/server/game/Server/WorldSocket.cpp
+++ b/src/server/game/Server/WorldSocket.cpp
@@ -888,7 +888,7 @@ int WorldSocket::HandleAuthSession (WorldPacket& recvPacket)
         */
 
     K.SetHexStr (fields[1].GetCString());
-
+    m_s = K;
     time_t mutetime = time_t (fields[7].GetUInt64());
 
     locale = LocaleConstant (fields[8].GetUInt8());
diff --git a/src/server/game/Server/WorldSocket.h b/src/server/game/Server/WorldSocket.h
index 7a121cb..d5a8bd7 100644
--- a/src/server/game/Server/WorldSocket.h
+++ b/src/server/game/Server/WorldSocket.h
@@ -40,6 +40,7 @@
 
 #include "Common.h"
 #include "AuthCrypt.h"
+#include "BigNumber.h"
 
 class ACE_Message_Block;
 class WorldPacket;
@@ -116,6 +117,9 @@ class WorldSocket : public WorldHandler
         /// Remove reference to this object.
         long RemoveReference (void);
 
+        /// Return the session key
+        BigNumber& GetSessionKey() { return m_s; }
+        
         /// things called by ACE framework.
 
         /// Called on open , the void* is the acceptor.
@@ -204,6 +208,8 @@ class WorldSocket : public WorldHandler
         bool m_OutActive;
 
         uint32 m_Seed;
+        
+        BigNumber m_s;        
 
 };
 
diff --git a/src/server/game/Warden/WardenMgr.cpp b/src/server/game/Warden/WardenMgr.cpp
new file mode 100644
index 0000000..c30166f
--- /dev/null
+++ b/src/server/game/Warden/WardenMgr.cpp
@@ -0,0 +1,1361 @@
+/*
+ * Copyright (C) 2008-2011 TrinityCore <http://www.trinitycore.org/>
+ * Copyright (C) 2005-2011 MaNGOS <http://getmangos.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "WardenMgr.h"
+#include "World.h"
+
+/*
+Useful information:
+
+- A module is chosen for 24H and saved. Next client connection the same day will reuse the
+  same module.
+- The client is kicked is he failed to load a module after the module is sent.
+- We ask the client to run between 5 and 9 cheat checks and we sent this request 12 to 15
+  seconds after his last reply.
+- The client is kicked if it did not reply 2 minutes after the cheat checks packet is sent
+- The client is kicked/banned if one test failed.
+*/
+
+WardenMgr::WardenMgr() : m_Disconnected(false), m_Banning(false), m_HalfCall(false)
+{
+    #if defined (ACE_HAS_EVENT_POLL) || defined (ACE_HAS_DEV_POLL)
+        ACE_Reactor::instance(new ACE_Reactor(new ACE_Dev_Poll_Reactor(ACE::max_handles(), 1), 1), true);
+    #endif
+}
+
+WardenMgr::~WardenMgr()
+{
+}
+
+void WardenMgr::Initialize(const char *addr, u_short port, bool IsBanning)
+{
+    // Save the address and port
+    m_WardendAddress = addr;
+    m_WardendPort = port;
+    m_Banning = IsBanning;
+    if (!LoadFromDB())
+    {
+        sLog->outError("Warden disabled because there is no usable module or 1 table has no record");
+        m_Enabled = false;
+        return;
+    }
+
+    if (m_Disconnected = !InitializeCommunication())
+    {
+        sLog->outError("Warden Daemon not reachable, trying to connect in the background");
+        m_PingOut = true;
+    }
+
+    m_PingTimer.SetInterval(30 * IN_MILLISECONDS);          // 10 secs
+    m_PingTimer.Reset();
+}
+
+bool WardenMgr::InitializeCommunication()
+{
+    // Establish the connection
+    m_Enabled = true;
+    WardenSvcHandler* handler = new WardenSvcHandler;
+
+    ACE_INET_Addr remoteAddr(m_WardendPort, m_WardendAddress.c_str());
+    if (m_connector.connect(handler, remoteAddr) == -1)
+    {
+        return false;
+    }
+
+    m_WardenProcessStream = handler->Peer;
+    ByteBuffer pkt;
+    const char *sign = WARDEND_SIGN;
+    pkt << sign;
+    m_WardenProcessStream->send((char const*)pkt.contents(), pkt.size());
+
+    m_PingOut = false;
+    return true;
+}
+
+// Triggered by world every 500ms
+void WardenMgr::Update(uint32 diff)
+{
+    if (!m_Enabled)
+        return;
+
+    m_PingTimer.Update(diff);
+
+    if (m_PingTimer.Passed())
+    {
+        if (m_PingOut && m_Disconnected)
+        {
+            m_Disconnected = !InitializeCommunication();
+            m_PingTimer.Reset();
+        }
+        else if (m_PingOut && !m_Disconnected)
+        {
+            sLog->outError("Connection to Warden Daemon lost, trying to reconnect in the background");
+            m_connector.close();
+            m_PingTimer.Reset();
+            m_PingTimer.SetCurrent(m_PingTimer.GetInterval()); // expire it
+            m_Disconnected = true;
+        }
+        else
+        {
+            SendPing();
+            m_PingTimer.Reset();
+        }
+    }
+
+    ACE_Time_Value t(0.001);
+    int res = ACE_Reactor::instance()->run_reactor_event_loop(t);
+}
+
+// Triggered by a session
+void WardenMgr::Update(WorldSession* const session)
+{
+    m_HalfCall = !m_HalfCall;                   // To return half of the time since called 2 times
+    if (!m_HalfCall)
+        return;
+
+    if (session->m_WardenTimer.Passed())        // We don't care the connection to wardend state to do cheat-checks or register
+    {
+        switch (session->m_wardenStatus)
+        {
+            case WARD_STATE_UNREGISTERED:
+                // register a client that could not register earlier
+                StartForSession(session);
+                return;
+            case WARD_STATE_LOAD_MODULE:       // no reply to load module request (20 secs)
+            case WARD_STATE_LOAD_FAILED:       // no reply after we sent the module to client (20 secs)
+                sLog->outError("Warden Manager: no reply received for module load or 2 times load failed, kicking account %u", session->GetAccountId());
+                session->KickPlayer();
+                return;
+            case WARD_STATE_TRANSFORM_SEED:    // no reply to transformed seed (20 secs)
+                sLog->outError("Warden Manager: no transformed seed received, kicking account %u", session->GetAccountId());
+                session->KickPlayer();
+                return;
+            case WARD_STATE_CHEAT_CHECK_OUT:   // timeout waiting for a cheat check reply
+                sLog->outError("Warden Manager: no Cheat-check reply received, kicking account %u", session->GetAccountId());
+                session->KickPlayer();
+                return;
+            case WARD_STATE_FORCE_CHEAT_CHECK_OUT:   // timeout waiting for a Force cheat check reply
+                sLog->outError("Warden Manager: no Force Cheat-check reply received, kicking account %u", session->GetAccountId());
+                session->KickPlayer();
+                return;
+            case WARD_STATE_CHEAT_CHECK_IN:    // send cheat check
+                SendCheatCheck(session);
+                session->m_wardenStatus = WARD_STATE_CHEAT_CHECK_OUT;
+                session->m_WardenTimer.SetInterval( 5 * MINUTE * IN_MILLISECONDS);
+                session->m_WardenTimer.Reset();
+                return;
+            case WARD_STATE_FORCE_CHEAT_CHECK_IN:    // send only memory cheat check
+                SendForceWEHCheatCheck(session);
+                session->m_wardenStatus = WARD_STATE_FORCE_CHEAT_CHECK_OUT;
+                session->m_WardenTimer.SetInterval( 5 * MINUTE * IN_MILLISECONDS);
+                session->m_WardenTimer.Reset();
+                return;
+            default:
+                break;
+        }
+    }
+
+    if (m_Disconnected)
+    {
+        session->m_WardenTimer.SetInterval( 15 * IN_MILLISECONDS); // push back warden activity in session by 15 seconds
+        session->m_WardenTimer.Reset();
+        if (session->m_wardenStatus == WARD_STATE_PENDING_WARDEND)
+            session->m_wardenStatus = WARD_STATE_NEED_WARDEND;     // We needed data, so have to redo the request
+        return;
+    }
+
+    // Connected to wardend, last time was disconnected, then resume and re-ask for module load and key generation
+    if (session->m_WardenTimer.Passed() && session->m_wardenStatus == WARD_STATE_NEED_WARDEND)
+    {
+        LoadModuleAndGetKeys(session);
+        session->m_WardenTimer.SetInterval(20 * IN_MILLISECONDS);
+        session->m_WardenTimer.Reset();
+        session->m_wardenStatus = WARD_STATE_PENDING_WARDEND;
+    }
+}
+
+bool WardenMgr::LoadFromDB()
+{
+    QueryResult result = WorldDatabase.Query("SELECT md5,chk0,chk1,chk2,chk3,chk4,chk5,chk6,chk7,chk8,end9 FROM warden_module");
+    if (!result)
+    {
+        m_WardenModuleMap.clear();
+        sLog->outString(">> Table warden_module is empty!");
+        sLog->outString();
+        return false;
+    }
+
+    uint32 count = 0;
+    {
+        do
+        {
+            Field *fields = result->Fetch();
+
+            std::string md5 = fields[0].GetString();
+            if (CheckModuleExistOnDisk(md5))
+            {
+                WardenCheckMap& moduleCheck = m_WardenModuleMap[md5];
+                moduleCheck.resize(10);
+
+                for (uint8 i=0; i<=9; ++i)
+                {
+                    moduleCheck[i] = fields[i+1].GetUInt8();
+                }
+
+                ++count;
+            }
+            else
+                sLog->outError("Module %s has a record in 'warden_module' but no binary on disk, skiping it", md5.c_str());
+
+        }
+        while(result->NextRow());
+
+        sLog->outString();
+        sLog->outString(">> Loaded %u warden modules", count);
+        if (count == 0)
+            return false;
+
+    }
+    // Now load the checks
+    // 1) memory
+    result = WorldDatabase.Query("SELECT String,Offset,Length,Result FROM warden_check_memory");
+    if (!result)
+    {
+        sLog->outString(">> Table warden_check_memory is empty!");
+        sLog->outString();
+        return false;
+    }
+    else
+    {
+        uint32 count = 0;
+        {
+            m_WardenMemoryChecks.resize((int)result->GetRowCount());
+            do
+            {
+                Field *fields = result->Fetch();
+
+                MemoryCheckEntry& current = m_WardenMemoryChecks[count];
+                current.String  = fields[0].GetString();
+                current.Offset  = fields[1].GetUInt32();
+                current.Length  = fields[2].GetUInt8();
+                std::string res = fields[3].GetString();
+                hexDecodeString(res.c_str(), res.length(), current.Result);
+
+                ++count;
+            }
+            while(result->NextRow());
+
+            sLog->outString();
+            sLog->outString(">> Loaded %u memory checks", count);
+            if (count == 0)
+                return false;
+        }
+    }
+    // 2) Page
+    result = WorldDatabase.Query("SELECT Seed,SHA,Offset,Length FROM warden_check_page");
+    if (!result)
+    {
+        sLog->outString(">> Table warden_check_page is empty!");
+        sLog->outString();
+        return false;
+    }
+    else
+    {
+        uint32 count = 0;
+        {
+            m_WardenPageChecks.resize((int)result->GetRowCount());
+            do
+            {
+                Field *fields = result->Fetch();
+
+                PageCheckEntry& current = m_WardenPageChecks[count];
+                current.Seed  = fields[0].GetUInt32();
+                std::string res = fields[1].GetString();
+                hexDecodeString(res.c_str(), 40, current.SHA);
+                current.Offset  = fields[2].GetUInt32();
+                current.Length  = fields[3].GetUInt8();
+
+                ++count;
+            }
+            while(result->NextRow());
+
+            sLog->outString();
+            sLog->outString(">> Loaded %u page checks", count);
+            if (count == 0)
+                return false;
+        }
+    }
+    // 3) File
+    result = WorldDatabase.Query("SELECT String,SHA FROM warden_check_file");
+    if (!result)
+    {
+        sLog->outString(">> Table warden_check_file is empty!");
+        sLog->outString();
+        return false;
+    }
+    else
+    {
+        uint32 count = 0;
+        {
+            m_WardenFileChecks.resize((int)result->GetRowCount());
+            do
+            {
+                Field *fields = result->Fetch();
+
+                FileCheckEntry& current = m_WardenFileChecks[count];
+                current.String  = fields[0].GetString();
+                std::string res = fields[1].GetString();
+                hexDecodeString(res.c_str(), 40, current.SHA);
+
+                ++count;
+            }
+            while(result->NextRow());
+
+            sLog->outString();
+            sLog->outString(">> Loaded %u file checks", count);
+            if (count == 0)
+                return false;
+        }
+    }
+    // 4) Lua
+    result = WorldDatabase.Query("SELECT String FROM warden_check_lua");
+    if (!result)
+    {
+        sLog->outString(">> Table warden_check_lua is empty!");
+        sLog->outString();
+        return false;
+    }
+    else
+    {
+        uint32 count = 0;
+        {
+            m_WardenLuaChecks.resize((int)result->GetRowCount());
+            do
+            {
+                Field *fields = result->Fetch();
+
+                LuaCheckEntry& current = m_WardenLuaChecks[count];
+                current.String = fields[0].GetString();
+
+                ++count;
+            }
+            while(result->NextRow());
+
+            sLog->outString();
+            sLog->outString(">> Loaded %u lua checks", count);
+            if (count == 0)
+                return false;
+        }
+    }
+    // 5) Driver
+    result = WorldDatabase.Query("SELECT Seed,SHA,String FROM warden_check_driver");
+    if (!result)
+    {
+        sLog->outString(">> Table warden_check_driver is empty!");
+        sLog->outString();
+        return false;
+    }
+    else
+    {
+        uint32 count = 0;
+        {
+            m_WardenDriverChecks.resize((int)result->GetRowCount());
+            do
+            {
+                Field *fields = result->Fetch();
+
+                DriverCheckEntry& current = m_WardenDriverChecks[count];
+                current.Seed    = fields[0].GetUInt32();
+                std::string res = fields[1].GetString();
+                hexDecodeString(res.c_str(), 40, current.SHA);
+                current.String  = fields[2].GetString();
+
+                ++count;
+            }
+            while(result->NextRow());
+
+            sLog->outString();
+            sLog->outString(">> Loaded %u driver checks", count);
+            if (count == 0)
+                return false;
+        }
+    }
+    return true;
+}
+
+bool WardenMgr::CheckModuleExistOnDisk(const std::string &md5)
+{
+    std::string modulekey  = sWorld->GetDataPath()+ "warden/" + md5 + ".key";
+    std::string modulefile = sWorld->GetDataPath()+ "warden/" + md5 + ".bin";
+    FILE* mf = fopen(modulefile.c_str(), "rb");
+    if (mf)
+    {
+        fclose(mf);
+        mf = fopen(modulekey.c_str(), "rb");
+        if (mf)
+        {
+            fclose(mf);
+            return true;
+        }
+    }
+    return false;
+}
+
+void WardenMgr::Register(WorldSession* const session)
+{
+    session->m_WardenTimer.SetInterval(5 * IN_MILLISECONDS);
+    session->m_WardenTimer.Reset();
+}
+
+void WardenMgr::ForceCheckForSession(WorldSession* const session)
+{
+    if (!m_Enabled)
+        return;
+
+    if (session->m_wardenStatus == WARD_STATE_UNREGISTERED ||
+        session->m_wardenStatus == WARD_STATE_FORCE_CHEAT_CHECK_OUT ||
+        session->m_wardenStatus == WARD_STATE_USER_DISABLED)
+        return;
+
+        session->m_wardenStatus = WARD_STATE_FORCE_CHEAT_CHECK_IN;
+        session->m_WardenTimer.SetInterval(5 * IN_MILLISECONDS);
+        session->m_WardenTimer.Reset();
+}
+
+void WardenMgr::StartForSession(WorldSession* const session)
+{
+    if (!m_Enabled)
+        return;
+
+    if (session->m_wardenStatus != WARD_STATE_UNREGISTERED)
+        return;
+
+    std::string md5;
+    std::string lastModule = "";
+    // Check if the user already had the module same day
+    time_t currenttime = time(NULL);
+    tm* now = localtime(&currenttime);
+    QueryResult result = LoginDatabase.PQuery("SELECT module_day,last_module,os FROM account WHERE id = '%u'", session->GetAccountId());
+    if (result)
+    {
+        Field* fields = result->Fetch();
+        uint16 modDay = fields[0].GetUInt16();
+        uint32 os = fields[2].GetUInt32();
+        if (os != 0x0057696E)       // 0x0057696E = \0niW => 'Win' so not windows, not coded yet for macho modules sending
+        {
+            session->m_wardenStatus = WARD_STATE_USER_DISABLED;
+            return;                 // OS not supported
+        }
+
+        if (modDay == now->tm_yday) // no need to change the module
+        {
+            lastModule = fields[1].GetString();
+            if (lastModule.length()!=32)
+            {
+                sLog->outStaticDebug("Login same day, tried to get last used module failed, maybe never used warden");
+                RandAModuleMd5(&md5);
+            }
+            else
+            {
+                md5 = lastModule;
+            }
+        }
+        else
+        {
+            sLog->outStaticDebug("Login different day, so new warden module");
+            RandAModuleMd5(&md5);
+        }
+        session->m_WardenModule = md5;
+        if (md5 != lastModule)
+            LoginDatabase.PExecute("UPDATE account SET last_module='%s',module_day=%u WHERE id = '%u'", md5.c_str(), now->tm_yday, session->GetAccountId());
+        SendLoadModuleRequest(session);
+        session->m_wardenStatus = WARD_STATE_LOAD_MODULE;
+        session->m_WardenTimer.SetInterval(40 * IN_MILLISECONDS);
+        session->m_WardenTimer.Reset();
+    }
+}
+
+void WardenMgr::Unregister(WorldSession* const session)
+{
+    if (session->m_WardenClientChecks)
+        delete (WardenClientCheckList*)session->m_WardenClientChecks;
+}
+
+void WardenMgr::RandAModuleMd5(std::string *result)
+{
+    std::vector<std::string> iList;
+    for (WardenModuleMap::const_iterator itr = m_WardenModuleMap.begin(); itr != m_WardenModuleMap.end(); ++itr)
+    {
+        iList.push_back(itr->first);
+    }
+    uint8 choice = urand(0, iList.size()-1);
+    *result = iList[choice];
+}
+
+void WardenMgr::SendLoadModuleRequest(WorldSession* const session)
+{
+    std::string modulekeyfile = sWorld->GetDataPath()+ "warden/" + session->m_WardenModule + ".key";
+
+    // Load .key file to get module length and module key
+    FILE* mf = fopen(modulekeyfile.c_str(), "rb");
+    if (!mf)
+        return; // If this happens, this mean the user deleted the file after startup
+
+    uint32 mod_length;
+    uint8 rc4[16];
+    uint8 binMd5[16];
+    hexDecodeString(session->m_WardenModule.c_str(), 32, binMd5);
+
+    fread(&mod_length, 1, 4, mf);
+    fread(rc4, sizeof(uint8)*16, 1, mf);
+    fclose(mf);
+
+    WorldPacket data( SMSG_WARDEN_DATA, 1+16+16+4 );
+    data << uint8(WARDS_MODULE_INFO);
+    data.append(binMd5, 16);
+    data.append(rc4, 16);
+    data << uint32(mod_length);
+
+    uint8 *skey = session->m_Socket->GetSessionKey().AsByteArray(40);
+    sWardenMgr->SetInitialKeys(&skey[0], &skey[20], &session->m_rc4ClientKey[0], &session->m_rc4ServerKey[0]);
+
+    // Then send the first packet to client
+    data.crypt(&session->m_rc4ServerKey[0], &rc4_crypt);
+    session->SendPacket(&data);
+}
+
+void WardenMgr::SendModule(WorldSession* const session)
+{
+    std::string modulekeyfile = sWorld->GetDataPath()+ "warden/" + session->m_WardenModule + ".key";
+    std::string modulefile = sWorld->GetDataPath()+ "warden/" + session->m_WardenModule + ".bin";
+
+    // Load .key file to get module length and module key
+    FILE* mf = fopen(modulekeyfile.c_str(), "rb");
+    if (!mf)
+        return; // Should not happen
+
+    uint32 modLength, remainLen;
+    uint8 rc4[16];
+    fread(&modLength, 1, 4, mf);
+    fread(rc4, sizeof(uint8)*16, 1, mf);
+    fclose(mf);
+
+    // Load the module encrypted binary
+    mf = fopen(modulefile.c_str(), "rb");
+    if (!mf)
+        return; // Should not happen
+
+    uint8* m_tmpModule;
+    uint16 offset = 0;
+    m_tmpModule = (uint8*)malloc(sizeof(uint8)*modLength);
+    fread(m_tmpModule, sizeof(uint8)*modLength, 1, mf);
+    fclose(mf);
+    remainLen = modLength;
+    while (remainLen > 0)
+    {
+        uint16 len = remainLen>500?500:remainLen;
+        WorldPacket data( SMSG_WARDEN_DATA, 1+2+len );
+        data << uint8(WARDS_MODULE_CHUNK);
+        data << uint16(len);
+        data.append(m_tmpModule + offset, len);
+        offset = offset + len;
+        remainLen = remainLen - len;
+
+        data.hexlike();
+        data.crypt(&session->m_rc4ServerKey[0], &rc4_crypt);
+        session->SendPacket(&data);
+    }
+    free(m_tmpModule);
+}
+
+void WardenMgr::SendSeedTransformRequest(WorldSession* const session)
+{
+    sLog->outStaticDebug("WardenMgr::SendSeedTransformRequest: Client packet");
+    WorldPacket data( SMSG_WARDEN_DATA, 1+16 );
+    data << uint8(WARDS_SEED);
+    data.append(&session->m_wardenSeed[0], 16);
+    data.hexlike();
+    data.crypt(&session->m_rc4ServerKey[0], &rc4_crypt);
+    session->SendPacket(&data);
+    session->m_wardenStatus = WARD_STATE_TRANSFORM_SEED;
+    session->m_WardenTimer.SetInterval(30 * IN_MILLISECONDS);
+    session->m_WardenTimer.Reset();
+}
+
+void WardenMgr::SendSeedAndComputeKeys(WorldSession* const session)
+{
+    sLog->outStaticDebug("WardenMgr::SendSeedAndComputeKeys: building wardend packet");
+    BigNumber s;
+    s.SetRand(16 * 8);
+    // save this seed for client send later when we have the new keys from wardend
+    memcpy(&session->m_wardenSeed[0], s.AsByteArray(16), 16);
+    // build the packet for wardend only
+    LoadModuleAndGetKeys(session);
+
+    // And we send this packet to the warden daemon for it to make the new key pair
+    session->m_wardenStatus = WARD_STATE_PENDING_WARDEND;
+}
+
+void WardenMgr::LoadModuleAndGetKeys(WorldSession* const session)
+{
+    if (!m_WardenProcessStream)
+        return;
+
+    std::string modulekeyfile = sWorld->GetDataPath()+ "warden/" + session->m_WardenModule + ".key";
+    std::string modulefile = sWorld->GetDataPath()+ "warden/" + session->m_WardenModule + ".bin";
+
+    // Load .key file to get module length and module key
+    FILE* mf = fopen(modulekeyfile.c_str(), "rb");
+    if (!mf)
+        return; // Modules have been tested at WardenMgr init, so have been deleted while core was running !
+
+    uint32 modLength;
+    uint8 rc4[16];
+    fread(&modLength, 1, 4, mf);
+    fread(rc4, sizeof(uint8)*16, 1, mf);
+    fclose(mf);
+
+    // Load the module encrypted binary
+    mf = fopen(modulefile.c_str(), "rb");
+    if (!mf)
+        return; // Same as above
+
+    uint8* m_tmpModule = (uint8*)malloc(sizeof(uint8)*modLength);
+    fread(m_tmpModule, sizeof(uint8)*modLength, 1, mf);
+    fclose(mf);
+
+    // Just decrypt it so that we don't even need to send the rc4
+    uint8 m_tmpKey[0x102];
+    rc4_init(m_tmpKey, rc4, 16);
+    rc4_crypt(m_tmpKey, m_tmpModule, modLength);
+
+    uint32 m_signature = *(uint32*)(m_tmpModule + modLength - 0x100 - 4); // - 256 bytes - sizeof(uint32)
+    if (m_signature != 0x5349474E) // NGIS->SIGN string
+    {
+        sLog->outBasic("Module damaged on disk");
+        return;
+    }
+
+    ByteBuffer pkt;
+    pkt << uint8(MMSG_LOAD_MODULE);
+    pkt << uint32(modLength - 0x100); // - 256 bytes certificate
+    pkt << uint32(session->GetAccountId());
+    pkt.append(m_tmpModule, modLength - 0x100);
+
+    pkt.append(session->m_Socket->GetSessionKey().AsByteArray(40), 40);
+    // Same as when we send this transformed seed request to client
+    pkt << uint8(WARDS_SEED);
+    pkt.append(&session->m_wardenSeed[0], 16);
+    free(m_tmpModule);
+
+    m_WardenProcessStream->send((char const*)pkt.contents(), pkt.size());
+}
+
+WardenMgr::MemoryCheckEntry *WardenMgr::GetRandMemCheck()
+{
+    return &m_WardenMemoryChecks[urand(0, m_WardenMemoryChecks.size()-1)];
+}
+WardenMgr::PageCheckEntry *WardenMgr::GetRandPageCheck()
+{
+    return &m_WardenPageChecks[urand(0, m_WardenPageChecks.size()-1)];
+}
+WardenMgr::FileCheckEntry *WardenMgr::GetRandFileCheck()
+{
+    return &m_WardenFileChecks[urand(0, m_WardenFileChecks.size()-1)];
+}
+WardenMgr::LuaCheckEntry *WardenMgr::GetRandLuaCheck()
+{
+    return &m_WardenLuaChecks[urand(0, m_WardenLuaChecks.size()-1)];
+}
+WardenMgr::DriverCheckEntry *WardenMgr::GetRandDriverCheck()
+{
+    return &m_WardenDriverChecks[urand(0, m_WardenDriverChecks.size()-1)];
+}
+
+void WardenMgr::SendForceWEHCheatCheck(WorldSession* const session)
+{
+    sLog->outStaticDebug("Wardend::SendForceWEHCheatCheck(%u, *pkt)", session->GetAccountId());
+
+    std::string md5 = session->m_WardenModule;
+    if (!session->m_WardenClientChecks)
+    {
+        session->m_WardenClientChecks = new WardenClientCheckList;
+    }
+    // Type cast and get a shorter name
+    WardenClientCheckList* checkList = (WardenClientCheckList*)session->m_WardenClientChecks;
+
+    checkList->clear();
+    // Get the Seed 1st byte for the xoring
+    uint8 m_seed1 = session->m_wardenSeed[0];
+    sLog->outStaticDebug("Seed byte: 0x%02X, end byte: 0x%02X", m_seed1, m_WardenModuleMap[md5][WARD_CHECK_END]);
+
+    WorldPacket data( SMSG_WARDEN_DATA, 300 ); // Guess size
+    data << uint8(WARDS_CHEAT_CHECK);
+
+    // Rand a number of checks between 4 and 8 checks + the first time check + end packet
+    uint8 nbChecks = 6;
+    checkList->resize(nbChecks);
+
+    for (uint8 i=0; i<nbChecks; ++i)
+    {
+            (*checkList)[i].check = WARD_CHECK_MEMORY;
+            (*checkList)[i].mem = GetRandMemCheck();
+            if ((*checkList)[i].mem->String.length())   // add 1 for the uint8 str length
+            {
+                data << uint8((*checkList)[i].mem->String.length());
+                data.append((*checkList)[i].mem->String.c_str() ,(*checkList)[i].mem->String.length());
+                sLog->outStaticDebug("Mem str %s, len %u", (*checkList)[i].mem->String.c_str(), (*checkList)[i].mem->String.length());
+            }
+    }
+    // strings terminator
+    data << uint8(0);
+    // We first add a timing check
+    data << uint8(m_WardenModuleMap[md5][WARD_CHECK_TIMING] ^ m_seed1);
+    // Finaly put the other checks
+    uint8 m_strIndex = 1;
+    sLog->outStaticDebug("Preparing %u checks", nbChecks);
+    for (uint8 i=0; i<nbChecks; ++i)
+    {
+        data << uint8(m_WardenModuleMap[md5][(*checkList)[i].check] ^ m_seed1);
+        sLog->outStaticDebug("%u : WARD_CHECK_MEMORY", i);
+        if ((*checkList)[i].mem->String.length())
+            data << uint8(m_strIndex++);
+        else
+            data << uint8(0);
+        data << uint32((*checkList)[i].mem->Offset);
+        data << uint8((*checkList)[i].mem->Length);
+    }
+    data << uint8(m_WardenModuleMap[md5][WARD_CHECK_END] ^ m_seed1);
+
+    data.hexlike();
+    data.crypt(&session->m_rc4ServerKey[0], &rc4_crypt);
+    session->SendPacket(&data);
+}
+
+void WardenMgr::SendCheatCheck(WorldSession* const session)
+{
+    sLog->outStaticDebug("Wardend::BuildCheatCheck(%u, *pkt)", session->GetAccountId());
+
+    std::string md5 = session->m_WardenModule;
+    if (!session->m_WardenClientChecks)
+    {
+        session->m_WardenClientChecks = new WardenClientCheckList;
+    }
+    // Type cast and get a shorter name
+    WardenClientCheckList* checkList = (WardenClientCheckList*)session->m_WardenClientChecks;
+
+    checkList->clear();
+    // Get the Seed 1st byte for the xoring
+    uint8 m_seed1 = session->m_wardenSeed[0];
+    sLog->outStaticDebug("Seed byte: 0x%02X, end byte: 0x%02X", m_seed1, m_WardenModuleMap[md5][WARD_CHECK_END]);
+
+    WorldPacket data( SMSG_WARDEN_DATA, 300 ); // Guess size
+    data << uint8(WARDS_CHEAT_CHECK);
+
+    // Rand a number of checks between 4 and 8 checks + the first time check + end packet
+    uint8 nbChecks = urand(4, 8);
+    checkList->resize(nbChecks);
+
+    for (uint8 i=0; i<nbChecks; ++i)
+    {
+        // We select one based on the ratio
+        float mRand = (float)rand_chance();
+        if (mRand < WCHECK_PAGE2_RATIO)                 // size 29, no string both page1 and page2 tests
+        {
+            (*checkList)[i].check = urand(0,1)?WARD_CHECK_PAGE1:WARD_CHECK_PAGE2;
+            (*checkList)[i].page = GetRandPageCheck();
+        }
+        else if (mRand < WCHECK_MEMORY_RATIO)           // size 6, possible string
+        {
+            (*checkList)[i].check = WARD_CHECK_MEMORY;
+            (*checkList)[i].mem = GetRandMemCheck();
+            if ((*checkList)[i].mem->String.length())   // add 1 for the uint8 str length
+            {
+                data << uint8((*checkList)[i].mem->String.length());
+                data.append((*checkList)[i].mem->String.c_str() ,(*checkList)[i].mem->String.length());
+                sLog->outStaticDebug("Mem str %s, len %u", (*checkList)[i].mem->String.c_str(), (*checkList)[i].mem->String.length());
+            }
+        }
+        else if (mRand < WCHECK_DRIVER_RATIO)
+        {
+            (*checkList)[i].check = WARD_CHECK_DRIVER;  // size 25 + string
+            (*checkList)[i].driver = GetRandDriverCheck();
+            data << uint8((*checkList)[i].driver->String.length());
+            data.append((*checkList)[i].driver->String.c_str(), (*checkList)[i].driver->String.length());
+            sLog->outStaticDebug("Driver str %s, len %u", (*checkList)[i].driver->String.c_str(), (*checkList)[i].driver->String.length());
+        }
+        else if (mRand < WCHECK_FILE_RATIO)
+        {
+            (*checkList)[i].check = WARD_CHECK_FILE;    // size 1 + string
+            (*checkList)[i].file = GetRandFileCheck();
+            data << uint8((*checkList)[i].file->String.length());
+            data.append((*checkList)[i].file->String.c_str(), (*checkList)[i].file->String.length());
+            sLog->outStaticDebug("File str %s, len %u", (*checkList)[i].file->String.c_str(), (*checkList)[i].file->String.length());
+        }
+        else
+        {
+            (*checkList)[i].check = WARD_CHECK_LUA;     // size 1 + string
+            (*checkList)[i].lua = GetRandLuaCheck();
+            data << uint8((*checkList)[i].lua->String.length());
+            data.append((*checkList)[i].lua->String.c_str(), (*checkList)[i].lua->String.length());
+            sLog->outStaticDebug("Lua str %s, len %u", (*checkList)[i].lua->String.c_str(), (*checkList)[i].lua->String.length());
+        }
+    }
+    // strings terminator
+    data << uint8(0);
+    // We first add a timing check
+    data << uint8(m_WardenModuleMap[md5][WARD_CHECK_TIMING] ^ m_seed1);
+    // Finaly put the other checks
+    uint8 m_strIndex = 1;
+    sLog->outStaticDebug("Preparing %u checks", nbChecks);
+    for (uint8 i=0; i<nbChecks; ++i)
+    {
+        data << uint8(m_WardenModuleMap[md5][(*checkList)[i].check] ^ m_seed1);
+        switch ((*checkList)[i].check)
+        {
+            case WARD_CHECK_PAGE1:
+            case WARD_CHECK_PAGE2:
+                sLog->outStaticDebug("%u : %s", i, (*checkList)[i].check==WARD_CHECK_PAGE1?"WARD_CHECK_PAGE1":"WARD_CHECK_PAGE2");
+                data << uint32((*checkList)[i].page->Seed);
+                data.append(&(*checkList)[i].page->SHA[0], 20);
+                data << uint32((*checkList)[i].page->Offset);
+                data << uint8((*checkList)[i].page->Length);
+                break;
+            case WARD_CHECK_MEMORY:
+                sLog->outStaticDebug("%u : WARD_CHECK_MEMORY", i);
+                if ((*checkList)[i].mem->String.length())
+                    data << uint8(m_strIndex++);
+                else
+                    data << uint8(0);
+                data << uint32((*checkList)[i].mem->Offset);
+                data << uint8((*checkList)[i].mem->Length);
+                break;
+            case WARD_CHECK_DRIVER:
+                sLog->outStaticDebug("%u : WARD_CHECK_DRIVER", i);
+                data << uint32((*checkList)[i].driver->Seed);
+                data.append(&(*checkList)[i].driver->SHA[0], 20);
+                data << uint8(m_strIndex++);
+                break;
+            case WARD_CHECK_FILE:
+                sLog->outStaticDebug("%u : WARD_CHECK_FILE", i);
+                data << uint8(m_strIndex++);
+                break;
+            case WARD_CHECK_LUA:
+                sLog->outStaticDebug("%u : WARD_CHECK_LUA", i);
+                data << uint8(m_strIndex++);
+                break;
+        }
+    }
+    data << uint8(m_WardenModuleMap[md5][WARD_CHECK_END] ^ m_seed1);
+
+    data.hexlike();
+    data.crypt(&session->m_rc4ServerKey[0], &rc4_crypt);
+    session->SendPacket(&data);
+}
+
+void WardenMgr::Pong()
+{
+    m_PingTimer.Reset();
+    m_PingOut = false;
+}
+
+void WardenMgr::SendPing()
+{
+    ByteBuffer pkt;
+    pkt << uint8(MMSG_PING);
+    m_WardenProcessStream->send((char const*)pkt.contents(), pkt.size());
+    m_PingOut = true;
+}
+
+void WardenMgr::SetInitialKeys(const uint8 *bSessionKey1, const uint8 *bSessionKey2, uint8* ClientKey, uint8 *ServerKey)
+{
+     uint8 bRandomData[20] = {0};
+     uint8 bRandomSource1[20] = {0};
+     uint8 bRandomSource2[20] = {0};
+
+     SHA1(bSessionKey1, 20, bRandomSource1);
+     SHA1(bSessionKey2, 20, bRandomSource2);
+
+     SHA_CTX mCtx;
+     SHA1_Init(&mCtx);
+
+     // compute hash
+     SHA1_Update(&mCtx, bRandomSource1, 20);
+     SHA1_Update(&mCtx, bRandomData, 20);
+     SHA1_Update(&mCtx, bRandomSource2, 20);
+
+     // finalize
+     SHA1_Final(bRandomData, &mCtx);
+
+     uint8 position = 0;
+     uint8 key[16] = {0};
+     for (uint8 i=0; i<16; ++i)
+     {
+         if (position >= 20)
+         {
+             SHA1_Init(&mCtx);
+             SHA1_Update(&mCtx, bRandomSource1, 20);
+             SHA1_Update(&mCtx, bRandomData, 20);
+             SHA1_Update(&mCtx, bRandomSource2, 20);
+             SHA1_Final(bRandomData, &mCtx);
+             position = 0;
+         }
+         key[i] = bRandomData[position];
+         ++position;
+     }
+     rc4_init(ClientKey, key, 16);
+
+     for (uint8 i=0; i<16; ++i)
+         key[i]=0;
+
+     for (uint8 i=0; i<16; ++i)
+     {
+         if (position >= 20)
+         {
+             SHA1_Init(&mCtx);
+             SHA1_Update(&mCtx, bRandomSource1, 20);
+             SHA1_Update(&mCtx, bRandomData, 20);
+             SHA1_Update(&mCtx, bRandomSource2, 20);
+             SHA1_Final(bRandomData, &mCtx);
+             position = 0;
+         }
+         key[i] = bRandomData[position];
+         ++position;
+     }
+     rc4_init(ServerKey, key, 16);
+}
+
+void WardenMgr::ChangeClientKey(WorldSession* const session)
+{
+    sLog->outStaticDebug("WardenMgr::ChangeClientKey");
+    memcpy(&session->m_rc4ClientKey[0], &session->m_WardenTmpClientKey[0], 0x102);
+}
+
+// Sending this packet to initialize engine functions warden uses
+void WardenMgr::SendWardenData(WorldSession* const session)
+{
+    sLog->outStaticDebug("WardenMgr::SendWardenData");
+    WorldPacket data( SMSG_WARDEN_DATA, 1 + 2+4+20 + 1 + 2+4+8 + 1 +2+4+8); // 42 // 57 // 3.3.5a init packet
+    data << uint8(WARDS_DATA);
+    {
+        data << uint16(20);
+        uint8 buff[20] =
+        {
+            0x01, 0x00, 0x02, 0x00,
+            0x80, 0x4F, 0x02, 0x00,     // 0x00400000 + 0x00024F80 SFileOpenFile
+            0xC0, 0x18, 0x02, 0x00,     // 0x00400000 + 0x000218C0 SFileGetFileSize
+            0x30, 0x25, 0x02, 0x00,     // 0x00400000 + 0x00022530 SFileReadFile
+            0x10, 0x29, 0x02, 0x00      // 0x00400000 + 0x00022910 SFileCloseFile
+        };
+        data << uint32(BuildChecksum(buff, 20));
+        data.append(buff, 20);
+    }
+    data << uint8(WARDS_DATA);
+    {
+        data << uint16(8);
+        uint8 buff[8] =
+        {
+           0x04, 0x00, 0x00,
+           0x40, 0x9D, 0x41, 0x00,      // 0x00400000 + 0x00419D40 FrameScript__GetText
+           0x01
+        };
+        data << uint32(BuildChecksum(buff, 8));
+        data.append(buff, 8);
+    }
+    // Computed part for timing checks (did not exist on Offy 3.3.5a)
+    data << uint8(WARDS_DATA);
+    {
+        data << uint16(8);
+        uint8 buff[8] =
+        {
+           0x01, 0x01, 0x00,
+           0x20, 0xAE, 0x46, 0x00,      // 0x00400000 + 0x0046AE20 PerformanceCounter
+           0x01
+        };
+        data << uint32(BuildChecksum(buff, 8));
+        data.append(buff, 8);
+    }
+
+    data.hexlike();
+    data.crypt(&session->m_rc4ServerKey[0], &rc4_crypt);
+    session->SendPacket(&data);
+}
+
+uint32 WardenMgr::BuildChecksum(const uint8* data, uint32 dataLen)
+{
+    uint8 hash[20];
+    SHA1(data, dataLen, hash);
+    uint32 checkSum = 0;
+    for (uint8 i=0; i<5; ++i)
+        checkSum = checkSum ^ *(uint32*)(&hash[0] + i*4);
+    return checkSum;
+}
+
+bool WardenMgr::ValidateTSeed(WorldSession* const session, const uint8 *codedClientTSeed)
+{
+    uint8 codedServerTSeed[20];
+    SHA1(&session->m_wardenSeed[0], 16, &codedServerTSeed[0]);
+    if (memcmp(&codedServerTSeed[0], codedClientTSeed, 20))
+    {
+        //ReactToCheatCheckResult(session, false);
+        session->KickPlayer();
+        sLog->outError("Warden Manager: no ValidateTSeed, kicking account %u", session->GetAccountId());
+        return false;
+    }
+    return true;
+}
+
+bool WardenMgr::ValidateCheatCheckResult(WorldSession* const session, WorldPacket& clientPacket)
+{
+    uint32 accountId = session->GetAccountId();
+    sLog->outStaticDebug("Wardend::ValidateCheatCheckResult(%u, *pkt)", accountId);
+    bool valid = true;
+
+    uint16 pktLen;
+    uint32 checksum;
+    clientPacket >> pktLen;
+    clientPacket >> checksum;
+    if (checksum != BuildChecksum(clientPacket.contents() + clientPacket.rpos(), clientPacket.size() - clientPacket.rpos()))
+    {
+        sLog->outError("Warden Cheat-check: Kicking account %u for failed check, Packet Checksum 0x%08X is invalid!", session->GetAccountId(), checksum);
+        //ReactToCheatCheckResult(session, false);
+        session->KickPlayer();
+        return false;
+    }
+
+    if (pktLen==0)
+        return false;
+
+    // parse the timing check always sent
+    sLog->outStaticDebug("TimeCheck");
+    uint8 res;
+    uint32 ticks;
+    clientPacket >> res; // should be 1
+    clientPacket >> ticks;
+    // Need to compare ticks based on last one using server ticks diff since
+    sLog->outStaticDebug("Time unk 0x%08X", ticks);
+    pktLen = pktLen - 5;
+
+    WardenClientCheckList* checkList = (WardenClientCheckList*)session->m_WardenClientChecks;
+    if (!checkList)
+        return false;
+
+    for (uint8 i=0; i<checkList->size(); ++i)
+    {
+        bool localCheck = true;
+        switch ((*checkList)[i].check)
+        {
+            case WARD_CHECK_TIMING:
+            {
+                sLog->outStaticDebug("TimeCheck");
+                uint8 res;
+                uint32 ticks;
+                clientPacket >> res; // should be 1
+                clientPacket >> ticks;
+                // Need to compare ticks based on last one using server ticks diff since
+                sLog->outStaticDebug("Time unk 0x%08X", ticks);
+                pktLen = pktLen - 5;
+                break;
+            }
+            case WARD_CHECK_MEMORY:
+            {
+                sLog->outStaticDebug("MemCheck");
+                uint8 res;
+                clientPacket >> res; // should be 0
+                if (res)
+                {
+                    localCheck = false;
+                    sLog->outBasic("Kicking account %u for failed check, MEM at Offset 0x%04X, lentgh %u could not be read by client", accountId, (*checkList)[i].mem->Offset, (*checkList)[i].mem->Length);
+                }
+                else
+                {
+                    uint8 memContent[20];
+                    for (uint8 pos=0; pos<(*checkList)[i].mem->Length; ++pos)
+                        clientPacket >> memContent[pos];
+                    if (memcmp(&memContent[0], &(*checkList)[i].mem->Result[0], (*checkList)[i].mem->Length))
+                        {
+                        localCheck = false;
+                        std::string strContent, strContent2;
+                        hexEncodeByteArray(memContent, (*checkList)[i].mem->Length, strContent);
+                        hexEncodeByteArray((*checkList)[i].mem->Result, (*checkList)[i].mem->Length, strContent2);
+                        sLog->outError("Kicking account %u for failed check, MEM Offset 0x%04X length %u has content '%s' instead of '%s'",
+                            accountId, (*checkList)[i].mem->Offset, (*checkList)[i].mem->Length, strContent.c_str(), strContent2.c_str());
+                    }
+                    pktLen = pktLen - (1 + (*checkList)[i].mem->Length);
+                }
+                sLog->outStaticDebug("Mem %s",localCheck?"Ok":"Failed");
+                break;
+            }
+            case WARD_CHECK_FILE:
+            {
+                sLog->outStaticDebug("MPQCheck");
+                uint8 res;
+                uint8 resSHA1[20];
+                clientPacket >> res; // should be 0
+                if (res)
+                {
+                    localCheck = false;
+                    sLog->outBasic("Kicking account %u for failed check, MPQ '%s' not found by client", accountId, (*checkList)[i].file->String.c_str());
+                    pktLen = pktLen - 1;
+                }
+                else
+                {
+                    for (uint8 pos=0; pos<20; ++pos)
+                        clientPacket >> resSHA1[pos];
+                    if (res || memcmp(resSHA1, (*checkList)[i].file->SHA, 20))
+                    {
+                        localCheck = false;
+                        std::string strResSHA1, strReqSHA1;
+                        hexEncodeByteArray(resSHA1, 20, strResSHA1);
+                        hexEncodeByteArray((*checkList)[i].file->SHA, 20, strReqSHA1);
+                        sLog->outError("Kicking account %u for failed check, MPQ '%s' SHA1 is '%s' instead of '%s'", accountId, (*checkList)[i].file->String.c_str(), strResSHA1.c_str(), strReqSHA1.c_str());
+                    }
+                    pktLen = pktLen - 21;
+                }
+                sLog->outStaticDebug("MPQ %s",valid?"Ok":"Failed");
+                break;
+            }
+            case WARD_CHECK_LUA:
+            {
+                sLog->outStaticDebug("LUACheck");
+                uint8 res;
+                uint8 foundLuaLen;
+                clientPacket >> res; // should be 0
+                clientPacket >> foundLuaLen; // should be 0
+                uint8 *luaStr;
+                if (foundLuaLen > 0)
+                {
+                    luaStr = (uint8*)malloc(foundLuaLen+1);
+                    for (uint8 pos=0; pos<foundLuaLen; ++pos)
+                    {
+                        clientPacket >> luaStr[pos];
+                    }
+                    luaStr[foundLuaLen] = 0;
+                    sLog->outError("Kicking account %u for failed check, Lua '%s' found as '%s'", accountId, (*checkList)[i].lua->String.c_str(), (char*)luaStr);
+                    localCheck = false;
+                    free(luaStr);
+                }
+                sLog->outStaticDebug("Lua %s",localCheck?"Ok":"Failed");
+                pktLen = pktLen - 2;
+                break;
+            }
+            case WARD_CHECK_PAGE1:
+            case WARD_CHECK_PAGE2:
+            case WARD_CHECK_DRIVER:
+            {
+                sLog->outStaticDebug("PageCheck or DriverCheck");
+                uint8 res;
+                clientPacket >> res; // should be 0xE9
+                if (res != 0xE9)
+                {
+                    if ((*checkList)[i].check == WARD_CHECK_DRIVER)
+                        sLog->outError("Kicking account %u for failed driver check '%s'", accountId ,(*checkList)[i].driver->String.c_str());
+                    else
+                        sLog->outError("Kicking account %u for failed page check Offset 0x%08X, length %u", accountId, (*checkList)[i].page->Offset, (*checkList)[i].page->Length);
+                    localCheck = false;
+                }
+                sLog->outStaticDebug("Page or Driver %s",localCheck?"Ok":"Failed");
+                pktLen = pktLen - 1;
+                break;
+            }
+            default:
+                sLog->outStaticDebug("Other!!");
+                // Finish skiping the rest of the packet and return failed checks
+                sLog->outBasic("Wrong packet for account %u or problem to parse it, I had to clean %u bytes", accountId, clientPacket.size() - clientPacket.rpos());
+                clientPacket.read_skip(clientPacket.size() - clientPacket.rpos());
+                return false;
+        }
+        valid = valid && localCheck;
+    }
+    return valid;
+}
+
+void WardenMgr::ReactToCheatCheckResult(WorldSession* const session, bool result)
+{
+    sLog->outStaticDebug("ReactToCheatCheckResult %s",result?"true":"false");
+    if (result)
+    {
+        session->m_wardenStatus = WARD_STATE_CHEAT_CHECK_IN;
+        const uint32 shortTime = urand(20, 35);                 // from 15 to 25 seconds
+        session->m_WardenTimer.SetInterval(shortTime * IN_MILLISECONDS);
+        sLog->outStaticDebug("Timer set to %u seconds", shortTime);
+        session->m_WardenTimer.SetCurrent(0);                   // so that we don't overload the timer
+    }
+    else
+    {
+        if (m_Banning)
+        {
+            std::string sText = ("player: " + std::string(session->GetPlayerName()) + " using cheat software and was banned for a day.");
+            sWorld->SendGMText(LANG_GM_BROADCAST, sText.c_str());
+            sWorld->BanAccount(session, 24 * HOUR, "Cheating software user", "Server guard");
+        }
+        else
+            session->KickPlayer();
+    }
+}
+
+/////////////////////////////
+// Session
+/////////////////////////////
+void WorldSession::HandleWardenRegister()
+{
+    if (sWardenMgr->IsEnabled() && m_wardenStatus == WARD_STATE_UNREGISTERED)
+        sWardenMgr->Register(this);
+}
+
+void WorldSession::HandleWardenUnregister()
+{
+    if (sWardenMgr->IsEnabled())
+        sWardenMgr->Unregister(this);
+}
+
+void WorldSession::HandleWardenDataOpcode(WorldPacket& recv_data)
+{
+    if (sWardenMgr->IsEnabled())
+    {
+        recv_data.crypt(m_rc4ClientKey, &rc4_crypt);
+        uint8 warden_opcode;
+        recv_data >> warden_opcode;
+        recv_data.hexlike();
+        switch(warden_opcode)
+        {
+            case WARDC_MODULE_LOAD_FAILED:
+                sLog->outStaticDebug("Received the reply load failed");
+                // We have to send the module
+                if (m_wardenStatus == WARD_STATE_LOAD_FAILED)
+                {
+                    sLog->outError("Warden status WARD_STATE_LOAD_FAILED: Kicking account %u for failed check!", GetAccountId());
+                    KickPlayer();
+                }
+                else
+                {
+                    sWardenMgr->SendModule(this);
+                    m_wardenStatus = WARD_STATE_LOAD_FAILED;
+                    m_WardenTimer.SetInterval(40 * IN_MILLISECONDS);
+                    m_WardenTimer.Reset();
+                }
+                break;
+            case WARDC_MODULE_LOADED:
+                sLog->outStaticDebug("Received the reply module loaded");
+                // We go next step: Send a seed
+                sWardenMgr->SendSeedAndComputeKeys(this);
+                m_WardenTimer.SetInterval(7 * IN_MILLISECONDS);
+                m_WardenTimer.Reset();
+                break;
+            case WARDC_CHEAT_CHECK_RESULT:
+            {
+                sLog->outStaticDebug("Received the cheat-check result");
+                bool result = sWardenMgr->ValidateCheatCheckResult(this, recv_data);
+                sWardenMgr->ReactToCheatCheckResult(this, result); // This sets the timer if needed
+                break;
+            }
+            case WARDC_TRANSFORMED_SEED:
+                sLog->outStaticDebug("Received the transformed seed");
+                // Let's validate this data
+                if (sWardenMgr->ValidateTSeed(this, recv_data.contents()+recv_data.rpos()))
+                {
+                    sWardenMgr->ChangeClientKey(this);
+                    sWardenMgr->SendWardenData(this);
+                    m_wardenStatus = WARD_STATE_CHEAT_CHECK_IN;
+                    m_WardenTimer.SetInterval(10 * IN_MILLISECONDS); // 3 secs before the 1st cheat check
+                    m_WardenTimer.Reset();
+                }
+                recv_data.read_skip(20);
+                break;
+            default:
+                sLog->outStaticDebug("Problem with packet");
+        }
+    }
+    else
+    {
+        recv_data.read_skip<uint8>();
+        sLog->outStaticDebug("Received opcode CMSG_WARDEN_DATA, but this session has no module linked");
+    }
+}
+
+//****************************************************
+// Warden Demon replies handlers
+
+const WardenSvcHandler::WardenMgrCmd table[] =
+{
+    { WMSG_WARDEN_KEYS,                 &WardenSvcHandler::_HandleNewKeys                   },
+    { WMSG_PONG,                        &WardenSvcHandler::_HandlePong                      }
+};
+
+#define WARDEN_REPLY_TOTAL_COMMANDS sizeof(table)/sizeof(WardenMgrCmd)
+
+int WardenSvcHandler::open(void*)
+{
+    sLog->outBasic("Connection to Warden Daemon established");
+    ACE_Reactor::instance()->register_handler(this, ACE_Event_Handler::READ_MASK);
+    Peer=&peer();
+    return 0;
+}
+
+int WardenSvcHandler::handle_input(ACE_HANDLE /*handle*/)
+{
+    uint8 _cmd;
+    Peer->recv_n(&_cmd, 1);
+
+    for (int i = 0; i < WARDEN_REPLY_TOTAL_COMMANDS; ++i)
+    {
+        if ((uint8)table[i].cmd == _cmd)
+        {
+            if (!(*this.*table[i].handler)())
+                return 0;
+            break;
+        }
+    }
+    return 0;
+}
+
+bool WardenSvcHandler::_HandleNewKeys()
+{
+    sLog->outStaticDebug("WardenSvcHandler::_HandleNewKeys()");
+    uint32 accountId;
+    Peer->recv_n(&accountId, 4);
+    WorldSession* session = sWorld->FindSession(accountId);
+    if (session) // in case client disconnected in between
+    {
+        // 1st, send the transformed seed request to client
+        sWardenMgr->SendSeedTransformRequest(session);
+        // now we can change the server key
+        Peer->recv_n(session->GetWardenServerKey(), 0x102);
+        // But we need a Transformed seed reply from client before changing the client key
+        // So saving it
+        Peer->recv_n(session->GetWardenTempClientKey(), 0x102);
+        // The seed can be overwritten since we did use the original one to build the client request
+        Peer->recv_n(session->GetWardenSeed(), 16);
+    }
+    else
+    {
+        // Trash the packet
+        uint8 trash;
+        for (uint32 i=0; i<(0x102+0x102+16); ++i)
+        {
+            Peer->recv_n(&trash, 1);
+        }
+    }
+    return true;
+}
+
+bool WardenSvcHandler::_HandlePong()
+{
+    sWardenMgr->Pong();
+    return true;
+}
\ No newline at end of file
diff --git a/src/server/game/Warden/WardenMgr.h b/src/server/game/Warden/WardenMgr.h
new file mode 100644
index 0000000..158e85a
--- /dev/null
+++ b/src/server/game/Warden/WardenMgr.h
@@ -0,0 +1,234 @@
+/*
+ * Copyright (C) 2008-2011 TrinityCore <http://www.trinitycore.org/>
+ * Copyright (C) 2005-2011 MaNGOS <http://getmangos.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef _WARDEN_MGR_H
+#define _WARDEN_MGR_H
+
+#include "Common.h"
+#include "SharedDefines.h"
+#include "Define.h"
+#include "WardenProtocol.h"
+#include "WorldSession.h"
+#include "Util.h"
+#include "BigNumber.h"
+#include "WorldPacket.h"
+#include "Opcodes.h"
+#include <ace/Connector.h>
+#include <ace/SOCK_Connector.h>
+#include <ace/SOCK_Stream.h>
+#include <ace/Svc_Handler.h>
+#include <ace/Dev_Poll_Reactor.h>
+#include <ace/Reactor.h>
+#include <ace/Singleton.h>
+
+#include <openssl/sha.h>
+
+// Definition of ratio of check types (based on a long session of 1162 checks)
+// They are cumulative, meaning that I add the %age to the previous one
+#define WCHECK_PAGE1_RATIO  15.0f   // 15.0%
+#define WCHECK_PAGE2_RATIO  30.0f   // 15.0%
+#define WCHECK_MEMORY_RATIO 94.0f   // 64.0%
+#define WCHECK_DRIVER_RATIO 97.4f   // 03.4%
+#define WCHECK_FILE_RATIO   98.7f   // 01.3%
+#define WCHECK_LUA_RATIO   100.0f   // 01.3%
+
+// State machine for warden activity on one session
+enum eWardenClientState
+{
+    WARD_STATE_UNREGISTERED,
+    WARD_STATE_LOAD_MODULE,
+    WARD_STATE_LOAD_FAILED,
+    WARD_STATE_TRANSFORM_SEED,
+    WARD_STATE_CHEAT_CHECK_IN,
+    WARD_STATE_CHEAT_CHECK_OUT,
+    WARD_STATE_USER_DISABLED,
+    WARD_STATE_PENDING_WARDEND,
+    WARD_STATE_NEED_WARDEND,
+    WARD_STATE_FORCE_CHEAT_CHECK_IN,
+    WARD_STATE_FORCE_CHEAT_CHECK_OUT,
+};
+
+class WardenSvcHandler: public ACE_Svc_Handler <ACE_SOCK_STREAM, ACE_NULL_SYNCH>
+{
+    public:
+        typedef struct WardenMgrCmd
+        {
+            eWardendOpcode cmd;
+            bool (WardenSvcHandler::*handler)(void);
+        }WardenHandler;
+
+        // Deamon replies related
+        bool _HandlePong();
+        bool _HandleNewKeys();
+
+        ACE_SOCK_Stream* Peer;
+        int open(void*);
+        int handle_input(ACE_HANDLE);
+
+    private:
+
+};
+
+typedef ACE_Connector<WardenSvcHandler, ACE_SOCK_CONNECTOR> WardendConnector;
+
+class WardenMgr
+{
+    public:
+        WardenMgr();
+        ~WardenMgr();
+        friend class ACE_Singleton<WardenMgr, ACE_Null_Mutex>;
+        void Initialize(const char* addr, u_short port, bool IsBanning);
+        void SetDisabled() { m_Enabled = false; }
+        bool IsEnabled() { return m_Enabled; }
+
+        // Update
+        void Update(uint32 diff); // Global Warden System update for packets send/receive
+        void Update(WorldSession* const session);               // Session specific update
+
+        // Connection Management
+    private:
+        void SendPing();
+    public:
+        void Pong();
+    private:
+        // Structure to store checks
+        struct MemoryCheckEntry
+        {
+            std::string String;
+            uint32 Offset;
+            uint8 Length;
+            uint8 Result[20];
+        };
+        struct PageCheckEntry
+        {
+            uint32 Seed;
+            uint8 SHA[20];
+            uint32 Offset;
+            uint8 Length;
+        };
+        struct FileCheckEntry
+        {
+            std::string String;
+            uint8 SHA[20];
+        };
+        struct LuaCheckEntry
+        {
+            std::string String;
+        };
+        struct DriverCheckEntry
+        {
+            uint32 Seed;
+            uint8 SHA[20];
+            std::string String;
+        };
+        struct ModuleCheckEntry
+        {
+            uint32 Seed;
+            uint8 SHA[20];
+        };
+        struct GenericCheck
+        {
+            uint8 check;
+            union
+            {
+                MemoryCheckEntry* mem;
+                PageCheckEntry* page;
+                FileCheckEntry* file;
+                LuaCheckEntry* lua;
+                DriverCheckEntry* driver;
+                ModuleCheckEntry* module;
+            };
+        };
+
+        typedef std::vector<uint8> WardenCheckMap; // store the check ids
+        typedef std::map<std::string, WardenCheckMap> WardenModuleMap; // module md5/check ids
+
+        typedef std::vector<MemoryCheckEntry> WardenMemoryChecks;
+        typedef std::vector<PageCheckEntry> WardenPageChecks;
+        typedef std::vector<FileCheckEntry> WardenFileChecks;
+        typedef std::vector<LuaCheckEntry> WardenLuaChecks;
+        typedef std::vector<DriverCheckEntry> WardenDriverChecks;
+        //typedef std::vector<ModuleCheckEntry> WardenModulehecks;
+
+        typedef std::vector<GenericCheck> WardenClientCheckList;
+
+    private:
+        bool InitializeCommunication();
+        bool LoadFromDB();
+        bool CheckModuleExistOnDisk(const std::string &md5);
+        void RandAModuleMd5(std::string *result);
+    public:
+        void Register(WorldSession* const session);
+        void ForceCheckForSession(WorldSession* const session);
+    private:
+        void StartForSession(WorldSession* const session);
+        void SetInitialKeys(const uint8 *bSessionKey1, const uint8 *bSessionKey2, uint8* ClientKey, uint8 *ServerKey);
+    public:
+        void SendLoadModuleRequest(WorldSession* const session);
+        void SendModule(WorldSession* const session);
+        void SendSeedAndComputeKeys(WorldSession* const session);
+        void SendSeedTransformRequest(WorldSession* const session);
+    private:
+        void LoadModuleAndGetKeys(WorldSession* const session);
+    public:
+        bool ValidateTSeed(WorldSession* const session, const uint8 *codedClientTSeed);
+        void ChangeClientKey(WorldSession* const session);
+        void SendWardenData(WorldSession* const session);
+    private:
+        void SendCheatCheck(WorldSession* const session);
+        void SendForceWEHCheatCheck(WorldSession* const session);
+    public:
+        bool ValidateCheatCheckResult(WorldSession* const session, WorldPacket& clientPacket);
+        void Unregister(WorldSession* const session);
+        void ReactToCheatCheckResult(WorldSession* const session, bool result);
+    private:
+        MemoryCheckEntry *GetRandMemCheck();
+        PageCheckEntry *GetRandPageCheck();
+        FileCheckEntry *GetRandFileCheck();
+        LuaCheckEntry *GetRandLuaCheck();
+        DriverCheckEntry *GetRandDriverCheck();
+
+        uint32 BuildChecksum(const uint8* data, uint32 dataLen);
+
+    protected:
+        ACE_SOCK_Stream *m_WardenProcessStream;
+        ACE_SOCK_Connector *m_WardenProcessConnection;
+
+        bool                    m_HalfCall;
+        bool m_Enabled;
+        bool m_PingOut;
+        bool m_Disconnected;
+        bool m_Banning;
+        std::string m_WardendAddress;
+        u_short m_WardendPort;
+        WardendConnector m_connector;
+        IntervalTimer m_PingTimer;
+
+        WardenModuleMap         m_WardenModuleMap;
+
+        WardenMemoryChecks m_WardenMemoryChecks;
+        WardenPageChecks m_WardenPageChecks;
+        WardenFileChecks m_WardenFileChecks;
+        WardenLuaChecks m_WardenLuaChecks;
+        WardenDriverChecks m_WardenDriverChecks;
+        //WardenModuleChecks    m_WardenModuleChecks;
+};
+
+#define sWardenMgr ACE_Singleton<WardenMgr, ACE_Null_Mutex>::instance()
+
+#endif
\ No newline at end of file
diff --git a/src/server/game/Warden/WardenProtocol.h b/src/server/game/Warden/WardenProtocol.h
new file mode 100644
index 0000000..94a3f3f
--- /dev/null
+++ b/src/server/game/Warden/WardenProtocol.h
@@ -0,0 +1,73 @@
+/*
+ * Copyright (C) 2008-2011 TrinityCore <http://www.trinitycore.org/>
+ * Copyright (C) 2005-2011 MaNGOS <http://getmangos.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef _PROTOCOL_H
+#define _PROTOCOL_H
+
+enum eWardendOpcode
+{
+    MMSG_PING                       = 0x01,
+    WMSG_PONG                       = 0x02,
+    MMSG_LOAD_MODULE                = 0x03,
+    //  uint32  moduleLen;
+    //  uint32  accountId;
+    //  uint8   module[moduleLen];
+    //  uint8   sessionKey[40];
+    //  uint8   clientPacket[17];
+    WMSG_WARDEN_KEYS                = 0x04,
+    //  uint32  accountId;
+    //  uint8   serverKey[258];
+    //  uint8   clientKey[258];
+    //  uint8   seed[16];
+};
+
+enum eWardenServerCmd
+{
+    WARDS_MODULE_INFO               = 0x00,
+    WARDS_MODULE_CHUNK              = 0x01,
+    WARDS_CHEAT_CHECK               = 0x02,
+    WARDS_DATA                      = 0x03,
+
+    WARDS_SEED                      = 0x05
+};
+
+enum eWardenClientCmd
+{
+    WARDC_MODULE_LOAD_FAILED        = 0x00,
+    WARDC_MODULE_LOADED             = 0x01,
+    WARDC_CHEAT_CHECK_RESULT        = 0x02,
+
+    WARDC_TRANSFORMED_SEED          = 0x04
+};
+
+enum eWardenCheckType
+{
+    WARD_CHECK_MEMORY               = 0,
+    WARD_CHECK_PAGE1                = 1,
+    WARD_CHECK_PAGE2                = 2,
+    WARD_CHECK_FILE                 = 3,
+    WARD_CHECK_LUA                  = 4,
+    WARD_CHECK_DRIVER               = 5,
+    WARD_CHECK_TIMING               = 6,
+    WARD_CHECK_PROCESS              = 7,
+    WARD_CHECK_MODULE               = 8,
+    WARD_CHECK_END                  = 9
+};
+
+#define WARDEND_SIGN "GuardM"
+#endif
\ No newline at end of file
diff --git a/src/server/game/World/World.cpp b/src/server/game/World/World.cpp
index 1bf6101..42558f3 100644
--- a/src/server/game/World/World.cpp
+++ b/src/server/game/World/World.cpp
@@ -74,6 +74,7 @@
 #include "CreatureTextMgr.h"
 #include "SmartAI.h"
 #include "Channel.h"
+#include "WardenMgr.h"
 
 volatile bool World::m_stopEvent = false;
 uint8 World::m_ExitCode = SHUTDOWN_EXIT_CODE;
@@ -1184,6 +1185,9 @@ void World::LoadConfigSettings(bool reload)
     // MySQL ping time interval
     m_int_configs[CONFIG_DB_PING_INTERVAL] = sConfig->GetIntDefault("MaxPingTime", 30);
 
+    // Warden ban time
+    m_bool_configs[CONFIG_UINT32_WARDEN_BAN_TIME] = sConfig->GetBoolDefault("Wardend.BanLength", 1);	
+
     sScriptMgr->OnConfigLoad(reload);
 }
 
@@ -1675,6 +1679,21 @@ void World::SetInitialWorldSettings()
     uint32 nextGameEvent = sGameEventMgr->StartSystem();
     m_timers[WUPDATE_EVENTS].SetInterval(nextGameEvent);    //depend on next event
 
+    if (sConfig->GetBoolDefault("wardend.enable", true))
+    {
+        sLog->outString("Starting Warden system...");
+        sWardenMgr->Initialize(sConfig->GetStringDefault("wardend.address","127.0.0.1").c_str(),
+        sConfig->GetIntDefault("wardend.port", 6555),
+        sConfig->GetBoolDefault("wardend.ban", false));
+        m_timers[WUPDATE_WARDEN].SetInterval(1 * IN_MILLISECONDS);
+    }
+    else
+    {
+        sLog->outString("Warden system disabled, skipping");
+        sWardenMgr->SetDisabled();
+    }
+
+
     // Delete all characters which have been deleted X days before
     Player::DeleteOldCharacters();
 
@@ -1948,6 +1967,18 @@ void World::Update(uint32 diff)
     sOutdoorPvPMgr->Update(diff);
     RecordTimeDiff("UpdateOutdoorPvPMgr");
 
+    ///- <li> Handle warden manager update
+    if (m_timers[WUPDATE_WARDEN].Passed())
+    {
+        ///- Update WardenTimer in all sessions
+        for (SessionMap::iterator itr = m_sessions.begin(); itr != m_sessions.end(); ++itr)
+            itr->second->UpdateWardenTimer(m_timers[WUPDATE_WARDEN].GetCurrent());
+
+        ///- Then call the update method of WardenMgr Singleton
+        sWardenMgr->Update(m_timers[WUPDATE_WARDEN].GetCurrent());
+        m_timers[WUPDATE_WARDEN].SetCurrent(0);
+    }
+
     ///- Delete all characters which have been deleted X days before
     if (m_timers[WUPDATE_DELETECHARS].Passed())
     {
@@ -2201,6 +2232,18 @@ void World::KickAllLess(AccountTypes sec)
             itr->second->KickPlayer();
 }
 
+BanReturn World::BanAccount(WorldSession *session, uint32 duration_secs, std::string reason, std::string author)
+{
+    LoginDatabase.PExecute("INSERT INTO account_banned VALUES ('%u', '%u', UNIX_TIMESTAMP(), UNIX_TIMESTAMP()+%u, '%s', '%s', '1')",
+    session->GetAccountId(),
+    sConfig->GetIntDefault("RealmID", 0),
+    duration_secs,
+    author.c_str(),
+    reason.c_str());
+    session->KickPlayer();
+    return BAN_SUCCESS;
+}
+
 /// Ban an account or ban an IP address, duration will be parsed using TimeStringToSecs if it is positive, otherwise permban
 BanReturn World::BanAccount(BanMode mode, std::string nameOrIP, std::string duration, std::string reason, std::string author)
 {
diff --git a/src/server/game/World/World.h b/src/server/game/World/World.h
index 1f3cd3c..96e8657 100644
--- a/src/server/game/World/World.h
+++ b/src/server/game/World/World.h
@@ -77,6 +77,7 @@ enum WorldTimers
     WUPDATE_MAILBOXQUEUE,
     WUPDATE_DELETECHARS,
     WUPDATE_PINGDB,
+    WUPDATE_WARDEN, // Because I don't want to create yet another thread
     WUPDATE_COUNT
 };
 
@@ -306,6 +307,7 @@ enum WorldIntConfigs
     CONFIG_PRESERVE_CUSTOM_CHANNEL_DURATION,
     CONFIG_PERSISTENT_CHARACTER_CLEAN_FLAGS,
     CONFIG_MAX_INSTANCES_PER_HOUR,
+    CONFIG_UINT32_WARDEN_BAN_TIME,    
     INT_CONFIG_VALUE_COUNT
 };
 
@@ -691,6 +693,7 @@ class World
         void KickAll();
         void KickAllLess(AccountTypes sec);
         BanReturn BanAccount(BanMode mode, std::string nameOrIP, std::string duration, std::string reason, std::string author);
+        BanReturn BanAccount(WorldSession *session, uint32 duration_secs, std::string reason, std::string author);
         bool RemoveBanAccount(BanMode mode, std::string nameOrIP);
         BanReturn BanCharacter(std::string name, std::string duration, std::string reason, std::string author);
         bool RemoveBanCharacter(std::string name);
diff --git a/src/server/shared/Database/Implementation/LoginDatabase.cpp b/src/server/shared/Database/Implementation/LoginDatabase.cpp
index 13cfe09..adc4abe 100644
--- a/src/server/shared/Database/Implementation/LoginDatabase.cpp
+++ b/src/server/shared/Database/Implementation/LoginDatabase.cpp
@@ -31,7 +31,7 @@ void LoginDatabaseConnection::DoPrepareStatements()
     PREPARE_STATEMENT(LOGIN_SET_ACCAUTOBANNED, "INSERT INTO account_banned VALUES (?, UNIX_TIMESTAMP(), UNIX_TIMESTAMP()+?, 'Trinity realmd', 'Failed login autoban', 1)", CONNECTION_ASYNC)
     PREPARE_STATEMENT(LOGIN_GET_SESSIONKEY, "SELECT a.sessionkey, a.id, aa.gmlevel  FROM account a LEFT JOIN account_access aa ON (a.id = aa.id) WHERE username = ?", CONNECTION_SYNCH)
     PREPARE_STATEMENT(LOGIN_SET_VS, "UPDATE account SET v = ?, s = ? WHERE username = ?", CONNECTION_ASYNC)
-    PREPARE_STATEMENT(LOGIN_SET_LOGONPROOF, "UPDATE account SET sessionkey = ?, last_ip = ?, last_login = NOW(), locale = ?, failed_logins = 0 WHERE username = ?", CONNECTION_ASYNC)
+    PREPARE_STATEMENT(LOGIN_SET_LOGONPROOF, "UPDATE account SET sessionkey = ?, last_ip = ?, last_login = NOW(), locale = ?, os = ?, failed_logins = 0 WHERE username = ?", CONNECTION_ASYNC)
     PREPARE_STATEMENT(LOGIN_GET_LOGONCHALLENGE, "SELECT a.sha_pass_hash, a.id, a.locked, a.last_ip, aa.gmlevel, a.v, a.s FROM account a LEFT JOIN account_access aa ON (a.id = aa.id) WHERE a.username = ?", CONNECTION_SYNCH)
     PREPARE_STATEMENT(LOGIN_SET_FAILEDLOGINS, "UPDATE account SET failed_logins = failed_logins + 1 WHERE username = ?", CONNECTION_ASYNC)
     PREPARE_STATEMENT(LOGIN_GET_FAILEDLOGINS, "SELECT id, failed_logins FROM account WHERE username = ?", CONNECTION_SYNCH)
diff --git a/src/server/shared/Packets/ByteBuffer.h b/src/server/shared/Packets/ByteBuffer.h
index 34bfea0..8b992d6 100644
--- a/src/server/shared/Packets/ByteBuffer.h
+++ b/src/server/shared/Packets/ByteBuffer.h
@@ -323,6 +323,17 @@ class ByteBuffer
             }
         }
 
+        template <class T>
+        void crypt(T& obj, uint8 *key, void(T::*func)(uint8 *useKey, uint8 *data, uint32 dataSize))
+        {
+            (obj.*(func))(key, &_storage[0], size());
+        }
+
+        void crypt(uint8 *key, void(*func)(uint8 *useKey, uint8 *data, uint32 dataSize))
+        {
+            (*func)(key, &_storage[0], size());
+        }
+		
         const uint8 *contents() const { return &_storage[0]; }
 
         size_t size() const { return _storage.size(); }
diff --git a/src/server/shared/Utilities/Util.cpp b/src/server/shared/Utilities/Util.cpp
index 3cea21f..00d12ff 100644
--- a/src/server/shared/Utilities/Util.cpp
+++ b/src/server/shared/Utilities/Util.cpp
@@ -51,10 +51,21 @@ double rand_norm(void)
     return sfmtRand->Random();
 }
 
+float rand_norm_f(void)
+{
+    return (float)sfmtRand->Random();
+}
+
 double rand_chance (void)
 {
     return sfmtRand->Random() * 100.0;
 }
+
+float rand_chance_f(void)
+{
+    return (float)sfmtRand->Random() * 100.0;
+}
+
 #else
 typedef ACE_TSS<MTRand> MTRandTSS;
 static MTRandTSS mtRand;
@@ -79,10 +90,20 @@ double rand_norm(void)
     return mtRand->randExc();
 }
 
+float rand_norm_f(void)
+{
+    return (float)mtRand->randExc ();
+}
+
 double rand_chance(void)
 {
     return mtRand->randExc(100.0);
 }
+
+float rand_chance_f(void)
+{
+    return (float)mtRand->randExc (100.0);
+}
 #endif
 
 Tokens::Tokens(const std::string &src, const char sep, uint32 vectorReserve)
@@ -415,7 +436,7 @@ std::wstring GetMainPartOfName(std::wstring wname, uint32 declension)
         { &ie_End[1], &i_End[1],    NULL,         NULL,        NULL,         NULL,         NULL,       NULL }
     };
 
-    for (wchar_t const* const* itr = &dropEnds[declension][0]; *itr; ++itr)
+    for (wchar_t const * const* itr = &dropEnds[declension][0]; *itr; ++itr)
     {
         size_t len = size_t((*itr)[-1]);                    // get length from string size field
 
@@ -519,3 +540,77 @@ void hexEncodeByteArray(uint8* bytes, uint32 arrayLen, std::string& result)
     result = ss.str();
 }
 
+// Function that converts string hex values into binary ones, support spaces in the string
+void hexDecodeString(const char *str, uint32 strlen, uint8* buffer)
+{
+    int8 startedNibble = 0x0F;
+    uint32 bufferId = 0;
+    for (uint32 i = 0; i < strlen; ++i)
+    {
+        char c = tolower(str[i]);
+        uint8 value = 0;
+        if (c >='0' && c <= '9')
+            value = c-'0';
+        else if (c>='a' && c<='f')
+            value = c-'a'+0xa;
+        else
+            continue;
+        if (startedNibble == 0x0F)
+            startedNibble = value<<4;
+        else
+        {
+            buffer[bufferId] = startedNibble | value;
+            startedNibble = 0x0F;
+            bufferId++;
+        }
+    }
+}
+
+// Simple RC4 to work on 256+2 bytes keys
+void byteSwap(uint8 *a, uint8 *b)
+{
+    uint8 t;
+    t = *a;
+    *a = *b;
+    *b = t;
+}
+
+void rc4_init(uint8 *key_buffer, uint8 *base, uint32 base_length)
+{
+    uint8 val = 0;
+    uint32 position = 0;
+    uint32 i;
+
+    for(i = 0; i < 0x100; i++)
+        key_buffer[i] = (uint8)i;
+
+    key_buffer[0x100] = 0;
+    key_buffer[0x101] = 0;
+
+    for(i = 1; i <= 0x40; i++)
+    {
+        val += key_buffer[(i * 4) - 4] + base[position++ % base_length];
+        byteSwap(&key_buffer[(i * 4) - 4], &key_buffer[val & 0x0FF]);
+
+        val += key_buffer[(i * 4) - 3] + base[position++ % base_length];
+        byteSwap(&key_buffer[(i * 4) - 3], &key_buffer[val & 0x0FF]);
+
+        val += key_buffer[(i * 4) - 2] + base[position++ % base_length];
+        byteSwap(&key_buffer[(i * 4) - 2], &key_buffer[val & 0x0FF]);
+
+        val += key_buffer[(i * 4) - 1] + base[position++ % base_length];
+        byteSwap(&key_buffer[(i * 4) - 1], &key_buffer[val & 0x0FF]);
+    }
+}
+
+void rc4_crypt(uint8 *key, uint8 *data, uint32 length)
+{
+    for(uint32 i = 0; i < length; i++)
+    {
+        key[0x100]++;
+        key[0x101] += key[key[0x100]];
+        byteSwap(&key[key[0x101]], &key[key[0x100]]);
+        data[i] ^= key[(key[key[0x101]] + key[key[0x100]]) & 0x0FF];
+    }
+}
+
diff --git a/src/server/shared/Utilities/Util.h b/src/server/shared/Utilities/Util.h
index 5ace48e..2465bf4 100644
--- a/src/server/shared/Utilities/Util.h
+++ b/src/server/shared/Utilities/Util.h
@@ -68,11 +68,15 @@ inline uint32 secsToTimeBitFields(time_t secs)
  * A double supports up to 15 valid decimal digits and is used internally (RAND32_MAX has 10 digits).
  * With an FPU, there is usually no difference in performance between float and double. */
  double rand_norm(void);
+ 
+ float rand_norm_f(void);
 
 /* Return a random double from 0.0 to 99.9999999999999. Floats support only 7 valid decimal digits.
  * A double supports up to 15 valid decimal digits and is used internaly (RAND32_MAX has 10 digits).
  * With an FPU, there is usually no difference in performance between float and double. */
  double rand_chance(void);
+ 
+ float rand_chance_f(void);
 
 /* Return true if a random roll fits in the specified chance (range 0-100). */
 inline bool roll_chance_f(float chance)
@@ -375,6 +379,13 @@ bool IsIPAddress(char const* ipaddress);
 uint32 CreatePIDFile(const std::string& filename);
 
 void hexEncodeByteArray(uint8* bytes, uint32 arrayLen, std::string& result);
+void hexDecodeString(const char *str, uint32 strlen, uint8* buffer);
+
+// Simple RC4 to work on 256+2 bytes keys
+void byteSwap(uint8 *a, uint8 *b);
+void rc4_init(uint8 *key_buffer, uint8 *base, uint32 base_length);
+void rc4_crypt(uint8 *key, uint8 *data, uint32 length);
+
 #endif
 
 //handler for operations on large flags
diff --git a/doc/HowToBuildWarden_Wine.txt b/doc/HowToBuildWarden_Wine.txt
new file mode 100644
index 0000000..c2a7267
--- /dev/null
+++ b/doc/HowToBuildWarden_Wine.txt
@@ -0,0 +1,56 @@
+Warden Installing to server with Debian x64
+
+1. Install needed packets (http://wiki.winehq.org/Recommended_Packages):
+# apt-get dep-build wine
+or install packets manually
+
+2. Install x32 libraries (http://wiki.winehq.org/WineOn64bit)
+# apt-get install ia32-libs libc6-dev-i386 lib32z1-dev ia32-libs-dev lib32ncurses5-dev
+
+If You compile wardend.exe with VS2010, need to install winbind:
+# apt-get install winbind
+
+3. Download wine http://sourceforge.net/projects/wine/files/Source/
+if present-version 1.3.13.
+
+4. Extract and configure wine:
+I used the keys:
+./configure --without-freetype --without-opengl --without-opencl --without-ldap --without-openal --without-mpg123
+--without-gstreamer --without-gsm --without-v4l --without-alsa --without-hal --without-jack --without-oss --without-esd
+--without-gettextpo --without-capi --without-cms --without-fontconfig --without-gphoto --without-cups --without-coreaudio
+--without-xcomposite --without-xcursor --without-xinerama --without-xinput --without-xrandr --without-xrender --without-xslt
+--without-glu --without-jpeg --without-sane --without-tiff --without-xshape --without-xxf86vm
+
+5. compile wine:
+# make
+
+and install wine:
+# make install
+
+6. Install dummy X server:
+# apt-get install xvfb
+
+7. Prepare to install MS Visual Studio libraries:
+-download script winetricks http://wiki.winehq.org/winetricks
+#  wget http://winetricks.org/winetricks
+
+-run dummy X server:
+# Xvfb :1 &
+#export DISPLAY=:1
+
+8. Install MS Visual Studio libraries:
+# sh winetricks vcrun2005
+or
+# sh winetricks vcrun2008
+or
+# sh winetricks vcrun2010
+
+9. Run wardend.exe
+# Xvfb :1 &
+#export DISPLAY=:1
+# wine wardend.exe
+
+Voila.
+
diff --git a/src/server/worldserver/worldserver.conf.dist b/src/server/worldserver/worldserver.conf.dist
index 76ed553..fa7beea 100644
--- a/src/server/worldserver/worldserver.conf.dist
+++ b/src/server/worldserver/worldserver.conf.dist
@@ -2780,3 +2780,37 @@ LevelReq.Mail = 1
 
 #
 ###################################################################################################
+
+
+##################################################################################################
+# WARDEN DAEMON - This daemon requires a Windows box to run. If you don't have any, let it disabled
+#
+#    Wardend.enable
+#        Enable or disable warden functionnalities
+#        Default: 0  - Disabled, worldserver will neither use wardend, not generate any warden related traffic
+#                 1  - Enable, worldserver will connect to wardend and generate cheat ckecks for all sessions
+
+Wardend.enable = 1
+
+#    Wardend.ban
+#        Enable or disable banning accounts
+#                 0  - Disabled, worldserver will kick accounts failing a cheat-check
+#        Default: 1  - Enable, worldserver will ban for 24H any account failing a cheat-check
+#
+
+Wardend.ban = 1
+
+#   Wardend.address
+#        IP Address of the computer running the Warden Daemon.
+#        Default: 127.0.0.1  - Assume you run the Warden Daemon on the same machine as Trinity Daemon
+
+Wardend.address = "127.0.0.1"
+
+#   Wardend.port
+#        Port on which the Warden Daemon listens
+#        Default: 6555
+
+Wardend.port = 6555
+
+#
+###################################################################################################
\ No newline at end of file
-- 
1.7.4.msysgit.0

